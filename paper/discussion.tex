% debug tools have bugs:
% 讽刺的是，我们crash了三个平台的debugger，尤其是在linux的gdb上，我们发现了不止一个bug，并且这些bug在最新版本仍然存在。比如，在linux最新版的gdb上输入"clear ,", "faas", "ed ,"都会导致segmentation fault。这是因为interactive utility的cmd后面没有加上正确的输入。
%基于这个发现，我们意识到，普通的fuzz并不适合interactive utility，因为将一行随机的乱码作为interactive的cmd并不具有针对性。如果我们随机生成的每一行的起始都是cmd可以识别的utility，我们认为发现bug的几率将会大大增加。

Our study demonstrates that fuzz tools are still effective in crashing/hanging utilities in modern Unix Systems. While certain bugs detected in previous studies have been fixed over time, additional bugs were detected by our updated fuzz tools. In the process of debugging, sometimes we found it difficult to identify the source of crashes or hangs due to the following challenges:

1. The source causing the bug was far from or seemingly irrelevant to the location of the bug. While debugging \texttt{bc} utility on MacOS, we found out one leaf node became a pointer by checking heap stack of this memory address. We traced through how this AVL tree was built, searched, and rotated and found out nothing. Since this pointer was used to access one deep copy of the token generated by \texttt{yylex}, we then traced through paths of where different deep copies go and found out that, this deep copy was added to a global array with index number exceeding the length of this array. 

2. The test cases failing utilities tend to be large, e.g. 120MB. If a utility hangs on such a big test file, it takes effort to distinguish between an unfinished run and a real hang before making judgement. For example, \texttt{tsort}, a wildly used utility for topological sort, did not finish on one of the largest test cases(119MB) in 300 seconds. However, it was not a hang, for it terminated after 40 minutes. 

3. The indeterministic failing behaviors with the same test case: the utilities might crash at this time but not the other time, the locations of crashes might differ from time to time, and how utilities process the random input or files might be different. To debug these utilities, we had to repeatedly run the debugging tools until the same results appeared, which was time-consuming.

% Besides challenges, there are some intriguing observations. A simple command \texttt{find -D} on Linux platform we tested leads to Segmentation fault. As mentioned in section2.4, this bug result from exceeding array bound by dereferencing argv[2]. 
% 在版本更新的过程中，新的问题出现了，比如find。虽然是一个短暂的错误，但是恰巧我们的平台安装了这个版本。 <string.h> 的strtok_r无法对null进行响应。


%popularity of fuzzing test:

% developer不重视fuzz，毕竟developer是最了解utility如何使用的人，如果他们使用fuzz工具，并且根据他们的经验来测试比较vulnerable的参数，那么发现bug的几率一定更大，从而提高reliability。




Although fuzz tools are efficient in detecting bugs resulting in program crashes or hangs, obviously not all bugs can be detected by fuzz. When using fuzz to test the reliability of programs, we should consider the following limits:

1. A program is detected as faulty only if there is a core dump or hang. Therefore, fuzz testing is less effective in uncovering security threats that do not lead to crashes and hangs, such as some viruses, worms, etc.

2. Fuzzing tests require significant time to implement effectively.

3. Test cases generated by fuzz tools can be extremely difficult to interpret, which makes debugging an arduous task.

4. Mangled invalid inputs might not penetrate very deep into the utility, therefore the crashes and hangs we caught might not be the only ones in a utility.


