
\begin{table}[htbp]  %table 里面也可以嵌套tabular,只有tabular是不能加标题的
\renewcommand\thetable{1}
\centering  %表格居中
 \begin{tabular}{|p{2.5cm}|p{2cm}|p{2cm}|p{2cm}|}  
     \hline
     \hline
        Utility & Linux & MacOS & FreeBSD \\ %[0.1ex]  %增加行宽
       \hline
       as & hang  &   &    \\
       awk &   &   &    \\
       bc &   & crash  & hang   \\
       bison &   &   &    \\
       calendar &   &   &    \\
       cat &   &   &    \\
       cc &   &   &    \\
       checknr & N/A  &   &  crash  \\
       cmp &   &   &    \\
       col &   &   &  crash  \\
       colcrt &   &   &    \\
       colrm &   &   &    \\
       comm &   &   &    \\
       compress & N/A  &   &    \\
       cpp &   &   &    \\
       csh &   &   &    \\
       ctags &   & crash  & crash   \\
       cut &   &   &   \\
       dc & hang  & hang  &    \\
       dd &   &   &    \\
       diff &   &   &    \\
       ed &   &   &    \\
       eqn &   &   &    \\
       \hline
       \hline
   \end{tabular}
   \caption{\textbf{List of Utilities Tested and the Systems on which They Were Tested (part 1)}}  %表格标题
\end{table}

\begin{table}[htbp]  %table 里面也可以嵌套tabular,只有tabular是不能加标题的
\renewcommand\thetable{1}
\centering  %表格居中
 \begin{tabular}{|p{2.5cm}|p{2cm}|p{2cm}|p{2cm}|}  
     \hline
     \hline
        Utility & Linux & MacOS & FreeBSD \\ %[0.1ex]  %增加行宽
       \hline
       ex &   &   &    \\
       expand &   &   &    \\
       expr &   &   &    \\
       f77 &   & N/A  & N/A   \\
       find & crash  &   &    \\
       flex &   & crash+hang  &    \\
       fmt &   &   &    \\
       fold &   &   &    \\
       ftp &   & N/A  &  crash  \\
       gcc &   &   &    \\
       gdb/lldb & crash(gdb)  & crash(lldb)  &  crash(gdb)  \\
       grep &   &   &    \\
       grn & N/A  &   &    \\
       groff & hang  & hang  &  hang  \\
       head &   &   &    \\
       htop &   &   &    \\
       indent & N/A  & crash+hang  & crash   \\
       join &   &   &    \\
       latex &   & N/A  &  N/A  \\
       look &   &   &    \\
       m4 &   &   &    \\
       mail &   &   &    \\
       \hline
       \hline
   \end{tabular}
   \caption{\textbf{List of Utilities Tested and the Systems on which They Were Tested (part 2)}}  %表格标题
\end{table}



\begin{table}[htbp]  %table 里面也可以嵌套tabular,只有tabular是不能加标题的
\renewcommand\thetable{1}
\centering  %表格居中
 \begin{tabular}{|p{2.5cm}|p{2cm}|p{2cm}|p{2cm}|} 
     \hline
     \hline
        Utility & Linux & MacOS & FreeBSD \\ %[0.1ex]  %增加行宽
       \hline
       make &   &   & crash   \\
       md5 & N/A  &   &    \\
       mdls & N/A  &   & N/A   \\
       mig & N/A  &   & N/A   \\
       more &   &   &    \\
       neqn &   &   &    \\
       nm &   &   &    \\
       nroff & hang  & hang  & hang \\
       pic &   &   &    \\
       pr &   &   &    \\
       ptx &   & N/A  & N/A   \\
       refer & N/A  &   &    \\
       rev &   &   &    \\
       sdiff &   &   &    \\
       sed &   &   &    \\
       sh &   &   &    \\
       soelim &   &   &    \\
       sort &   &   &    \\
       spell & hang  & N/A  & N/A   \\
       split &   &   &    \\
       \hline
       \hline
   \end{tabular}
   \caption{\textbf{List of Utilities Tested and the Systems on which They Were Tested (part 3)}}  %表格标题
\end{table}



\begin{table}[htbp]  %table 里面也可以嵌套tabular,只有tabular是不能加标题的
\renewcommand\thetable{1}
\centering  %表格居中
 \begin{tabular}{|p{2.5cm}|p{2cm}|p{2cm}|p{2cm}|} 
     \hline
     \hline
        Utility & Linux & MacOS & FreeBSD \\  %增加行宽
       \hline
       strings &   &   &    \\
       strip &   &   &    \\
       sum &   &   &    \\
       tail &   &   &    \\
       tbl &   &   &    \\
       tee &   &   &    \\
       telnet &   &   &    \\
       tex &   & N/A  & N/A   \\
       tr &   &   &    \\
       troff & crash  & crash  & crash   \\
       tsort &   & hang  &    \\
       ul &   &   &    \\
       uniq &   &   &    \\
       units & N/A  &   &    \\
       vim &   &   &    \\
       vgrind & N/A  & N/A  &  hang  \\
       wc &   &   &    \\
       xargs &   &   &    \\
       yacc &   &   &    \\
       zic &   &   &    \\
       zsh & hang  & hang  & crash+hang   \\
       \hline
       \# tested & 76  & 79  &  79  \\
       \# crashes/hangs & 9  & 13  &  14  \\
       \% & 12\%  & 16\%  & 18\%   \\ 
       \hline
       \hline
   \end{tabular}
   \caption{\textbf{List of Utilities Tested and the Systems on which They Were Tested (part 4)}}  %表格标题
\end{table}


In this section, we recapitulated the fuzz tests reported in our 1990, 1995, and 2006 studies on Unix-based systems using the updated fuzz tools described above. In the previous studies, we tested the reliability of utilities by random input streams on a variety of Unix platforms, but the majority of them are now obsolete. Therefore, our current study focused on widely-used modern Unix variants, including Linux, MacOS, and FreeBSD. Linux was tested on machines in computer science labs at the UW-Madison, with Ubuntu 18.04.3, GCC version 7.4.0 and CPU x86\_64. MacOS was tested on personal computers with MacOS Mojave version 10.14.5, Apple LLVM version 10.0.0, and 2.4GHz Intel Core i5. FreeBSD was installed on VirtualBox 6.0.14 platform using FreeBSD-11.3-RELEASE-amd64-disc1.iso file and configured as follows: 4GB memory and 20GB dynamic allocated virtual box disk. Linux and MacOS were tested in the 1995 and 2006 fuzz studies respectively, and the results were compared to our current study. Xv6 was run on QEMU emulator.




\subsection{Quantitative Test Results}
We tested 86 utilities across three platforms: Linux, MacOS, and FreeBSD. 70 of them are available in all three platforms. Table 1 lists all utilities tested across three platforms, and the utilities that were crashed or hung by our tests. We detected a total of 17 failed utilities, 9 in Linux, 13 in MacOS, and 14 in FreeBSD. 5 utilities (\texttt{troff}, \texttt{nroff}, \texttt{groff}, \texttt{zsh}, and \texttt{gdb/lldb}) were crashed or hung in all three platforms, while the others were failed in one or two systems. 

The failure rate of Linux in the current study (9/76, 12\%) is slightly higher than that in the 1995 study (5/55, 9\%). Of the five Linux utilities that were crashed or hung in the 1995 fuzz study, \texttt{dbx} and \texttt{indent} are no longer available in the current Linux system, \texttt{ctags}, \texttt{lex} and \texttt{ul} were not crashed or hung in our current studies. However, we detected crash or hang in 9 additional Linux utilities. 7 of them were not tested previously, while the other 2(\texttt{as} and \texttt{nroff}) were tested but not failed in the 1995 study. One possible explanation for the additional hangs and crashes detected in the current study is that we generated fuzz input of much greater size  (up to 1e8 characters) than any previous studies (up to 1e5 characters), and thus exerted enough stress on the utilities to induce crashes or hangs. 

Similarly, we detected a higher rate of failure in MacOS (13/79, 16\%) than the 2006 fuzz study (10/135, 7\%). One possible explanation is that in the current study, we did not test as many utilities as in the 2006 study, and none of the untested utilities in the current study were crashed or hung in the 2006 study. Of the 10 utilities that were crashed in the 2006 study, \texttt{expr}, \texttt{zic}, \texttt{as}, \texttt{ul}, and \texttt{vim} were not crashed or hung in our current study, \texttt{groff}, \texttt{zsh}, and \texttt{nroff} were hung instead of crashed while, \texttt{troff} was still crashed and \texttt{indent} had both crash and hang in our current study. 

Comparison between the current study and two previous fuzz studies revealed that some of the bugs that caused utilities to fail in the previous studies were fixed over the years, while some of these bugs still persists. However, we crashed or hung additional utilities in our current study. This could partially result from our updated fuzz test method that included larger size input and random selection of command line arguments.

The failure rate of FreeBSD (14/79, 18\%), is the highest among the three platforms we tested. Since FreeBSD was not tested in previous fuzz studies, we do not know how its reliability changed over the years. However, based on the above data, we can conclude that the reliability of utilities in Linux and MacOS is better than that in FreeBSD.

For Xv6, we tested 6 out of 10 utilities in the Xv6 environment, including \texttt{echo}, \texttt{wc}, \texttt{kill}, \texttt{grep}, \texttt{cat}, and \texttt{mkdir}. However, we did not find any crashes or hangs.



\subsection{Causes of Crashes and Hangs}
To find out the causes of utility failure, we examined each utility that was crashed or hung using the following method. 

First, we found out the version of each failed utility and obtained its source code. For Linux, we used GNU official website as our main source. For MacOS, we searched for Apple’s official document to locate the source code. For FreeBSD, we obtained the utility source code from github. Then we compiled the source code with desired flags on each platform in our own working directory. We changed the default prefix and the directory to install the utilities to avoid overwriting the existing utilities. Additionally, we used “-O0” flag to avoid compiler optimization and added “-g” flag to allow debugging. Finally, we used debugger to trace bugs and stepped through the program to find out the causes of failure. We used \texttt{gdb} and \texttt{strace} on Linux, \texttt{gdb} on FreeBSD, and \texttt{lldb} on MacOS. 

Using the above method, we categorized the causes of each utility failure into the following categories.


\subsubsection{Failure to Check Return Value}
Not checking the return value of a called function seems to be a silly mistake; however, this mistake is still present in modern codes, even codes from GNU free software. Programmers often assume that a call can never fail or it is too much work or inconvenient to handle the case when it does fail. Unfortunately, these assumptions are often wrong. In the following code of \texttt{troff}, the function \texttt{fontno} will return -1 with invalid input. However, the program does not check the return value; instead, -1 is directly used as an index number for the array font\_table[ ], which exceeds the range of the array and causes the program to crash. This mistake can be easily avoided by checking the return value of \texttt{fontno}, and throw an error when the return value is -1.
\begin{verbatim}
special_node()
{
...
    int fontno = env_definite_font(curenv);
    tf = font_table[fontno]->get_tfont(fs, char_height, char_slant, fontno);
...
}
\end{verbatim}

Another example is \texttt{gdb}, which uses the input name to open a TUI window. When the input name is not found, a NULL pointer is returned. However, the program does not check the return value, instead it tries to access the window through the NULL pointer and caused the crash. 

\begin{verbatim}
parse_scroll_args(char* arg, struct tui_win_info** win_to_scroll)
{
    ...
    *win_to_scroll = tui_partial_win_by_name(uname)
    // *win_to_scroll was 0x0
    ...
    tui_scroll(win_to_scroll);
    // crashed
    ...
}

struct tui_win_info* tui_partial_win_by_name(char* name)
{
    struct tui_win_info* win_info = NULL;
    ...
    // failed to find the window by name
    ...
    return win_info;
    // NULL was returned
}
\end{verbatim}


\subsubsection{Pointer/Array}
Although pointer/array errors did not dominate the results of our current fuzz test as they did in the 1995 and 2006 studies, such errors still exist in current Unix utilities. The programmer made implicit assumptions about the contents of the data being processed, which caused the programmer to use insufficient checks on their loop termination conditions. Such errors were often simple, for example, the Linux utility \texttt{find} assumes there is an argument following the flag “-D”. Therefore, it automatically reads the next element without checking the size of the array. When “-D” is not followed by any arguments, argv[i+1] will exceed the boundary of the array and \texttt{0x0} will be passed to strtok\_r, which leads to crash.

\begin{verbatim}
process_leading_options()
{
    ...
    if (0 == strcmp ("-D", argv[i]))
        {
            process_debug_options (argv[i+1]);
            ++i; 
        }
    ...
}
process_debug_options(char* arg)
{
    ...
    p = strtok_r (arg, delimiters, &token_context);
    ...
}
\end{verbatim}


Another severe but pernicious problem caused by pointer/array error is heap memory corruption. It might not directly cause program failure, but undermine the integrity of heap causing fatal error at some later points. For example, the MacOS utility \texttt{bc} was programmed to access array memory before checking if the array needed to be resized. 

\begin{verbatim}
lookup(name, namekind)
{
    ...
    id->a_name = next_array++;
    a_names[id->a_name] = name;
    ...
    if (id->a_name >= a_count)
	    more_arrays();
    ...
}
\end{verbatim}

It first put one pointer to \texttt{name} in the array \texttt{a\_names} accessed by an index number \texttt{id->a\_name}. It then checked if this index number \texttt{id->a\_name} was greater or equal to the \texttt{a\_count}, which was the length of array \texttt{a\_names} to decide whether to grow the array. Each time, the index number \texttt{id->a\_name} was incremented by 1. The largest valid index number of one array was 1 less than the length of this array. Hence, it allowed writing on one section of heap memory which did not belong to the allocated array. 

In our debugging processes, this heap memory corruption crashed this utility for two reasons: 

1. The checksum of free block on heap was contaminated. This crash happened in \texttt{malloc} function. 

2. The leaf node of the tree-structured symbol table was overwritten. While reading that memory section, the program assumed a memory address on heap. The contaminated memory contained the content of symbol name. When the program tried to treat this content as heap memory address, the segmentation fault happened.



\subsubsection{Bad Error Handling}
Similar to pointer/array errors, the programmer often assumes that the input should meet certain criteria, thus does not use sufficient checks on their loop termination condition to handle input errors. The utility \texttt{make} in FreeBSD is representative: the \texttt{for} loop terminates when the number of left parentheses equals to the number of right parentheses. Since the random input did not have equal numbers of "(" and ")" , the \texttt{for} loop would never terminate, which made the pointer to a string keep increasing until it reached an invalid address and crashed the program.

Another example of bad error handling is caused by using unreliable macro, \texttt{assert}, in the case of utility \texttt{flex} on MacOS. It was programmed to have an array-structured stack to trace the depth of the input. When a "(" was read, \texttt{sf\_push} was called. When a ")" was read, \texttt{sf\_pop} was called. The variable \texttt{\_sf\_top\_ix} was to track how many elements in the stack, which was also the index number to put a new element. This variable was initially set to 0. While parsing our test case, the \texttt{flex} first read a ")" before reading any "(". Hence it called \texttt{sf\_pop} when \texttt{\_sf\_top\_ix} was 0. 

\begin{verbatim}
sf_pop (void)
{
    assert(_sf_top_ix > 0);
    --_sf_top_ix;
}
\end{verbatim}

In \texttt{sf\_pop}, before \texttt{\_sf\_top\_ix} was decremented by 1, it called assert to check if \texttt{\_sf\_top\_ix}  was larger than 0. However, assert.h file was not included because \texttt{HAVE\_ASSERT\_H} was false. At this condition, \texttt{assert(Pred)} was defined but its function body was not declared. 

\begin{verbatim}
#ifdef HAVE_ASSERT_H
#include <assert.h>
#else
#define assert(Pred)
#endif
\end{verbatim}

As a result, \texttt{\_sf\_top\_ix} was decremented by 1 whose value became the max value of a 8 bytes unsigned integer, 18,446,744,073,709,551,615. Later, when \texttt{sf\_push} was called, it tried to access the array-structured stack by the index of 18,446,744,073,709,551,615. This caused a page fault hence crashing the program.

\subsubsection{Sub-processes}
A robust program might crash if it invokes a vulnerable program as a sub-process. In our current study as well as previous fuzz studies, on FreeBSD platform, \texttt{nroff}, \texttt{groff}, and \texttt{vgrind} crashed because they called \texttt{troff} as a sub-process. As we described before, troff can be crashed by certain input due to unchecked return value. Thus, the test cases that crashed \texttt{troff} would also crash \texttt{nroff}, \texttt{groff}, and \texttt{vgrind}.

\subsubsection{Exceed Buffer Size}
\texttt{spell} is a spell-checking utility which scans a text file for misspelled words. In the source code, it forks to create a child process and lets the child process run \texttt{ispell} using \texttt{exec()}. In the parent process, the input from \texttt{stdin} is written to a pipe. In the child process, the pipe serves as the \texttt{stdin} of \texttt{ispell}. When parent process writes a long string to the pipe, which exceeds the capacity of the pipe, the writer hangs.



\subsubsection{Others}
\texttt{dc} is a reverse-polish calculator which supports arbitrary-precision arithmetic. Some arithmetic with high precision will take a long time, which cannot be considered as hang. For example, in the fuzz test, one test case triggered a square root operation, requiring 800000 digits after the decimal point. However, it will be user-friendly to show the current step or to estimate remaining time.

Although we did not find any crashes or hangs on Xv6, we detected another unreliability of this platform. What we found out is that Xv6 allows \texttt{kill} to terminate the init process, whose pid number is 1. It causes the Xv6 system to report error and fail to respond. In Linux, only signals for which init has explicitly installed signal handlers can be sent to process ID 1, the init process\cite{KILL(2)}. It protects the unexpected errors and improves the robustness of the system. Similar modifications should be applied to Xv6 to avoid this error. 

