

% 虽然我们更新了fuzz工具，并且使其跨平台，并且可以随机选择options。但是fuzz工具还有很多提升空间。比如我们可以更系统地对options进行fuzz。
% 1 尝试non-exist options，或者使用unprintable的乱码作为options。
% 2 尝试需要输入的options，但是不加输入或加入乱码作为输入。
% 3 尝试指定每一个option的合理区间，比如数字的范围，字符串的长度等，然后对整个options空间进行fuzz。虽然很难穷尽每一种组合，但是我们的工具可以系统地覆盖所有的可能，这样增加了发现bug的机会。
% 这里最好举个例子。



Although we have updated the fuzz tools to make it work cross-platform and included random combination of options during testing, we can further improve it to enable more systematic fuzz testing.

Ironically, we discovered bugs of debugger tools on all three platforms. Especially on Linux, we found out more than one bugs in \texttt{gdb}, which still exist in the latest version. Moreover, these bugs are not something hidden deeply. To crash the latest version of \texttt{gdb} on Linux, one can just start \texttt{gdb} and type in:

\texttt{"clear ,"}

or \texttt{"ed ,"} 

or \texttt{"faas"}

The above bugs are all caused by invalid arguments after a command in \texttt{gdb}. Based on this discovery, we found that test cases generated by fuzz without any other processes are not suitable for tests on interactive command-line utilities, such as \texttt{gdb} and \texttt{telnet}. If every line of a test case starts with a random valid command that the utility can recognize, which is followed by a random string, the chance of detecting bugs could be greatly enhanced. For example, to fuzz \texttt{gdb}, a line of the modified test case can be:

\texttt{"breakpoint" + a random string}

or \texttt{"clear" + a random string}

or \texttt{"next" + a random string}

In addition, to make the test more comprehensive, we would like to test how utilities react to random non-existing options. Furthermore, for options followed by inputs, it will be instructive to know how they react to invalid arguments. By specifying the requirement of each option in man page syntax, we can describe the option space to be fuzzed. 
For example:

\texttt{stdin find [-P] [-L] [-H] [-D exec|opt|tree] [-Olevel 0|1] [-maxdepth int(0, 20)] [-name string(5, 10)] [-anewer file(./test/)]}

Then the testing script will parse the description and randomize the options as follows: randomly choose options in \texttt{[]} with a probability of 0.5 for each option; for -D option, randomly select one argument among "exec", "opt" and "tree"; for -Olevel option, randomly select one between "0" and "1"; for -maxdepth option, randomly draw an integer from [0, 20); for -name option, randomly generate a string, with length ranging from 5 to 9; for -anewer option, randomly select a file from "./test" directory.

The above systematic fuzz tool will be of great use to developers and researchers, since the option space is under user's control. No one knows a utility better than its developer, and the developers could do more targeted testing on some vulnerable options using this tool. Moreover, for some utilities, the whole option space can be fuzzed with the help of it.
