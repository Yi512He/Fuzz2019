To apply fuzz testing to the Unix systems we selected, we need to update the fuzz tools originated from the 1990 fuzz study. Section 2.1 describes how we updated the fuzz and ptyjig program and testing script for Linux, MacOS and FreeBSD. Section 2.2 describes how we developed fuzz tools for Xv6. 

\subsection{Fuzz Tools for Linux, MacOS and FreeBSD}

\subsubsection{Fuzz}
The fuzz program, first developed in the 1990 fuzz study, is a generator of random characters. It produces a continuous string of characters on its standard output file. We can generate different types of outputs by specifying the options given to fuzz. These options allow fuzz to produce both printable and control characters, only printable characters, or either of these groups along with the NULL (zero) character. We can also specify a delay between each character. This option can account for the delay in characters passing through a pipe and help the user locate the characters that caused a utility to crash. Another option allows us to specify the seed for the random number generator for future reproduction. Fuzz can record its output stream in a file, in addition to printing to standard output. This file can be examined later. There are options to randomly insert NEWLINE characters in the output stream, and to limit the length of the output stream. 

To apply fuzz tests to the current Unix platforms, we first modified the syntax of the fuzz program to accommodate for the current coding standards. Instead of feeding the utilities with output directly from the fuzz generator, we generated four groups of test cases with varying lengths of input files and then fed the utilities these test files using the python script described in Section 2.1.3. The four groups of test cases were generated as follows using different combinations of options: 

1. 1200 small files with 0-1e3 characters or 1-100 lines with 0-50 characters per line.

2. 900 normal files with 0-1e5 lines with 1-255 characters per line, including the 12 test cases from the 1995 fuzz study.

3. 180 big files with 1e6-1e7 characters or 1e4-1e5 lines with 0-1e5 characters per line.

4. 60 huge files with 1e7-1e8 characters or 1e5-1e6 lines with 0-1e5 characters per line.  

\subsubsection{Ptyjig}
The original ptyjig from the 1990 fuzz study was designed for testing interactive utilities, such as vim and htop. ptyjig first creates a child process using fork(). The child process opens an available tty device, copies this tty to its stdin and stdout and then runs the interactive utility by calling exec(). Parent process opens the corresponding pseudo-tty device (pty), creates another child process to write the test data to pty, and keeps reading utility output from pty. With the help of ptyjig, we can apply the fuzzing test to interactive utilities.

However, due to some obsolete macros and functions, the original ptyjig can not be compiled on current systems. Therefore, we made the following updates:

1. We updated the arguments of wait3(). The first argument of wait3() serves as a record of the termination status of child process. We changed its data type from union* to int*.

2. We updated the way to open pty and tty. In the earlier version of Unix systems, there were pseudo-tty devices in /dev/ named “pty\%c\%x”, with \%c ranging from p to s and \%x ranging from 0 to 15. Ptyjig will go through all pty devices until it finds an available pty device. On the contrary, in today’s systems, these devices are not displayed in /dev/. Instead, users call \texttt{posix\_openpt()} to dynamically allocate a slave (pty), and then call \texttt{ptsname()} to find the filename of the corresponding master (tty) and open it.

3. We updated the return value of ptyjig. The original ptyjig checks the termination status of the interactive utility, but does not return it to the operating system. In the updated ptyjig, if the interactive utility crashes, ptyjig will return 139 to operating system, which can be captured by the testing script.

4. We made it compatible with multiple platforms. We determined the current operating system by checking predefined macros.


\subsubsection{Testing Script}
To test the utilities using the test cases generated by the fuzz program, we wrote a set of python scripts that automated testing of all the utilities. We chose to write python scripts because python works cross-platform, is easy to write and understand, and provides packages that allow executing sub-processes, parsing input strings, and selecting random options.

First, we added the utilities to be tested to a run.master file using the following syntax:

\texttt{[stdin|file|cp|two\_files] cmd [options pool]}


\texttt{stdin}, \texttt{file}, \texttt{cp}, or \texttt{two\_files} were chosen for each utility based on the type of input it takes. The script will test each utility against test cases in the four groups generated by fuzz. In addition, we added options that do not require arguments to the option pool for each command. For each test case, the python script will randomly choose options from the option pool with a probability of 0.5 for each option.

For example: 

\texttt{file as [-a -D -L -R -v -W -Z -w -x]}

\texttt{stdin bc [-l -w -s -q]}

\texttt{cp t.c cc [-c -S -E]}

\texttt{two\_files diff [-s -e -p -T]}

In the above example, a test case is fed into utility \texttt{as} as a file; utility \texttt{bc} gets input from standard input; a test case is copied to \texttt{t.c}, which is then fed info utility \texttt{cc} because utility \texttt{cc} only recognizes files with extension \texttt{".c"}; two test cases are fed into utility \texttt{diff}.

Moreover, we modified our testing script to automatically detect crash or hang of the utilities. To detect crash, we check the return value of each test. If the return value is 139, the utility being tested is crashed. To test hang, we set a timeout argument at 300 seconds. If the sub-process is not completed before the time expires, a timeout exception will be thrown and recorded by the test script.

The python script can also automate testing for interactive utilities. Similarly, we added the utilities to be tested to a run.master file using the following code:

\texttt{pty cmd [options pool]}

For example: 

\texttt{pty vim [-A -b -d]}

Unlike basic utilities, every interactive utility needs a specific operation to quit. For example, in vim, we need to type in ESC to go back to normal mode and type in \texttt{:wq} or \texttt{:q!} to quit vim. 
Therefore, before testing an interactive utility, the python script will append the corresponding end to the original test data to prevent a hang that is caused by the lack of a quit operation.


\subsection{Fuzz Tools for Xv6}
Xv6 is a simple Unix-like operating system which lacks system calls used in our original fuzz program. Therefore, we made the following changes to the fuzz program and used it to test utilities in Xv6.

We modified the original fuzz code to generate random character output files in an Xv6 environment. Xv6 does not support the following functions used in fuzz: \texttt{rand}, \texttt{srand}, \texttt{fflush}, \texttt{fopen}, \texttt{fclose}, \texttt{sprintf}, \texttt{sscanf} and \texttt{getc}. Therefore, we wrote \texttt{rand} and \texttt{srand} functions, used Xv6-supported \texttt{open} and \texttt{close} functions, and simply read in command line arguments and then converted them into integer or string to replace the above functions. Hence, in an Xv6 environment, we could run fuzz testing using the following code:

\texttt{fuzz [length] -o [outfile] | [cmd]}  

We modified Xv6 shell source code to run 10 tests for each of the six utilities for one execution. To test utilities reading from standard input, we called fuzz to generate files with random characters and piped the output. For utilities only processing command line arguments, we generated randomized command line arguments. 

We made the above changes based on two considerations: 

1. The capacity of the current Xv6 file system is 71680 bytes. Though it is possible to expand its capacity to 16MB, it requires changing its inode structure to support doubly-indirect memory blocks by modifying source codes\cite{Xv6manual}. Since the test cases generated for basic tests are close to 20 GB, it would be impossible to apply them directly to Xv6.

2. Only three utilities in Xv6 can be tested by canonical fuzz output, which are \texttt{grep}, \texttt{cat}, and \texttt{wc}. Therefore, we added randomized command line arguments to test three more utilities in Xv6, which are \texttt{kill}, \texttt{mkdir}, and \texttt{echo}. 